//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by \generate-code.bat.
//
//     Changes to this file will be lost when the code is regenerated.
//     The build server regenerates the code before each build and a pre-build
//     step will regenerate the code on each local build.
//
//     See https://github.com/angularsen/UnitsNet/wiki/Adding-a-New-Unit for how to add or edit units.
//
//     Add CustomCode\Quantities\MyQuantity.extra.cs files to add code to generated quantities.
//     Add UnitDefinitions\MyQuantity.json and run generate-code.bat to generate new units or quantities.
//
// </auto-generated>
//------------------------------------------------------------------------------

// Licensed under MIT No Attribution, see LICENSE file at the root.
// Copyright 2013 Andreas Gullberg Larsen (andreas.larsen84@gmail.com). Maintained at https://github.com/angularsen/UnitsNet.

using System;
using System.Globalization;
using UnitsNet.Units;
using System.Collections.Generic;

#nullable enable

namespace UnitsNet
{
    /// <summary>
    ///     Dynamically parse or construct quantities when types are only known at runtime.
    /// </summary>
    public static partial class Quantity
    {
        /// <summary>
        /// All QuantityInfo instances mapped by quantity name that are present in UnitsNet by default.
        /// </summary>
        public static readonly IDictionary<string, QuantityInfo> ByName = new Dictionary<string, QuantityInfo>
        {
            { "AmountOfSubstance", AmountOfSubstance.Info },
            { "Duration", Duration.Info },
            { "ElectricCurrent", ElectricCurrent.Info },
            { "Length", Length.Info },
            { "LuminousIntensity", LuminousIntensity.Info },
            { "Mass", Mass.Info },
            { "Pressure", Pressure.Info },
            { "Temperature", Temperature.Info },
        };

        /// <summary>
        /// Dynamically constructs a quantity of the given <see cref="QuantityInfo"/> with the value in the quantity's base units.
        /// </summary>
        /// <param name="quantityInfo">The <see cref="QuantityInfo"/> of the quantity to create.</param>
        /// <param name="value">The value to construct the quantity with.</param>
        /// <returns>The created quantity.</returns>
        public static IQuantity FromQuantityInfo(QuantityInfo quantityInfo, QuantityValue value)
        {
            return quantityInfo.Name switch
            {
                "AmountOfSubstance" => AmountOfSubstance.From(value, AmountOfSubstance.BaseUnit),
                "Duration" => Duration.From(value, Duration.BaseUnit),
                "ElectricCurrent" => ElectricCurrent.From(value, ElectricCurrent.BaseUnit),
                "Length" => Length.From(value, Length.BaseUnit),
                "LuminousIntensity" => LuminousIntensity.From(value, LuminousIntensity.BaseUnit),
                "Mass" => Mass.From(value, Mass.BaseUnit),
                "Pressure" => Pressure.From(value, Pressure.BaseUnit),
                "Temperature" => Temperature.From(value, Temperature.BaseUnit),
                _ => throw new ArgumentException($"{quantityInfo.Name} is not a supported quantity.")
            };
            }

        /// <summary>
        ///     Try to dynamically construct a quantity.
        /// </summary>
        /// <param name="value">Numeric value.</param>
        /// <param name="unit">Unit enum value.</param>
        /// <param name="quantity">The resulting quantity if successful, otherwise <c>default</c>.</param>
        /// <returns><c>True</c> if successful with <paramref name="quantity"/> assigned the value, otherwise <c>false</c>.</returns>
        public static bool TryFrom(QuantityValue value, Enum unit, out IQuantity? quantity)
        {
            switch (unit)
            {
                case AmountOfSubstanceUnit amountOfSubstanceUnit:
                    quantity = AmountOfSubstance.From(value, amountOfSubstanceUnit);
                    return true;
                case DurationUnit durationUnit:
                    quantity = Duration.From(value, durationUnit);
                    return true;
                case ElectricCurrentUnit electricCurrentUnit:
                    quantity = ElectricCurrent.From(value, electricCurrentUnit);
                    return true;
                case LengthUnit lengthUnit:
                    quantity = Length.From(value, lengthUnit);
                    return true;
                case LuminousIntensityUnit luminousIntensityUnit:
                    quantity = LuminousIntensity.From(value, luminousIntensityUnit);
                    return true;
                case MassUnit massUnit:
                    quantity = Mass.From(value, massUnit);
                    return true;
                case PressureUnit pressureUnit:
                    quantity = Pressure.From(value, pressureUnit);
                    return true;
                case TemperatureUnit temperatureUnit:
                    quantity = Temperature.From(value, temperatureUnit);
                    return true;
                default:
                {
                    quantity = default(IQuantity);
                    return false;
                }
            }
        }

        /// <summary>
        ///     Try to dynamically parse a quantity string representation.
        /// </summary>
        /// <param name="formatProvider">The format provider to use for lookup. Defaults to <see cref="CultureInfo.CurrentCulture" /> if null.</param>
        /// <param name="quantityType">Type of quantity, such as <see cref="Length"/>.</param>
        /// <param name="quantityString">Quantity string representation, such as "1.5 kg". Must be compatible with given quantity type.</param>
        /// <param name="quantity">The resulting quantity if successful, otherwise <c>default</c>.</param>
        /// <returns>The parsed quantity.</returns>
        public static bool TryParse(IFormatProvider? formatProvider, Type quantityType, string quantityString, out IQuantity? quantity)
        {
            quantity = default(IQuantity);

            if (!typeof(IQuantity).IsAssignableFrom(quantityType))
                return false;

            var parser = QuantityParser.Default;

            return quantityType switch
            {
                Type _ when quantityType == typeof(AmountOfSubstance) => parser.TryParse<AmountOfSubstance, AmountOfSubstanceUnit>(quantityString, formatProvider, AmountOfSubstance.From, out quantity),
                Type _ when quantityType == typeof(Duration) => parser.TryParse<Duration, DurationUnit>(quantityString, formatProvider, Duration.From, out quantity),
                Type _ when quantityType == typeof(ElectricCurrent) => parser.TryParse<ElectricCurrent, ElectricCurrentUnit>(quantityString, formatProvider, ElectricCurrent.From, out quantity),
                Type _ when quantityType == typeof(Length) => parser.TryParse<Length, LengthUnit>(quantityString, formatProvider, Length.From, out quantity),
                Type _ when quantityType == typeof(LuminousIntensity) => parser.TryParse<LuminousIntensity, LuminousIntensityUnit>(quantityString, formatProvider, LuminousIntensity.From, out quantity),
                Type _ when quantityType == typeof(Mass) => parser.TryParse<Mass, MassUnit>(quantityString, formatProvider, Mass.From, out quantity),
                Type _ when quantityType == typeof(Pressure) => parser.TryParse<Pressure, PressureUnit>(quantityString, formatProvider, Pressure.From, out quantity),
                Type _ when quantityType == typeof(Temperature) => parser.TryParse<Temperature, TemperatureUnit>(quantityString, formatProvider, Temperature.From, out quantity),
                _ => false
            };
            }

        internal static IEnumerable<Type> GetQuantityTypes()
        {
            yield return typeof(AmountOfSubstance);
            yield return typeof(Duration);
            yield return typeof(ElectricCurrent);
            yield return typeof(Length);
            yield return typeof(LuminousIntensity);
            yield return typeof(Mass);
            yield return typeof(Pressure);
            yield return typeof(Temperature);
        }
    }
}
